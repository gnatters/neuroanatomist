Jax.getGlobal()['AssetLoader'] = Jax.Model.create
  after_initialize: ->
    # this model is responsible for finding, fetching and returning requested meshes, regions, descriptions, indexes etc
    # particularly in service of scene and region
    # also responsible for local caching of assets
    # can bundle assets into a single request to the server to reduce overhead
    
    # create jax asset store
    # all meshes are stripped out of the loaded asset and stored here by id, where region can find them later
    @s3 = window.context.s3 = {}
    @idb = 
      indexedDB:    window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB
      keyRange:     window.IDBKeyRange || window.webkitIDBKeyRange
      db:           null
      ready:        false
      config:
        stores:     ["shape_set","shapes","meshes","regions","perspectives","logs"]
        name:       "neuroanatomist"
        version:    "0.0.1"
        key:        "sid"
    $.extend @idb,
      init: (() =>
        req = @idb.indexedDB.open @idb.config.name
        req.onsuccess = (e) => 
          @idb.db = idb = e.target.result
          missing_stores = (os for os in @idb.config.stores when !idb.objectStoreNames.contains(os))
          if missing_stores
            vreq = idb.setVersion @idb.config.version
            vreq.onsuccess = (e) => 
              idb.createObjectStore os, { keyPath: @idb.config.key } for os in missing_stores
              @idb.ready = true
            vreq.onfailure = () => console.log "ERROR: setVersion failed."; console.log e
          else @idb.ready = true
        req.onerror = (e) => console.log "ERROR: Unable to open indexedDB"; console.log e
        return { request: () -> req }
      )()
              
      get: (os, id, success, failure) =>
        request = @idb.indexedDB.open @idb.db
        request.onsuccess = (e) =>
          idb = e.target.result
          if idb.objectStoreNames.contains os
            active_store = idb.transaction([os], "readwrite").objectStore(os)
            get_request = active_store.get id
            get_request.onsuccess = (e) =>
              if e.target.result
                success e.target.result
              else failure
            get_request.onerror = (e) ->
              console.log "ERROR: Unable to retrieve data"
              failure
          else failure
        request.onerror = (e) ->
          console.log "ERROR: Unable to open indexedDB"
          failure
      
      
      put: (os, new_version, data, idb) =>
        if idb
          if idb.objectStoreNames.contains os
            active_store = idb.transaction([os], "readwrite").objectStore(os)
            put_request = active_store.put data
            put_request.onsuccess = (e) -> console.log "Data stored in indexedDB"
            put_request.error = (e) -> console.log "Error putting data"; console.log e
          else
            version_request = idb.setVersion new_version
            version_request.onsuccess = (e) =>
              active_store = idb.createObjectStore os, { keyPath: "id" }
              put_request = active_store.put data
              put_request.onsuccess = (e) -> console.log "Data stored in indexedDB"
              put_request.error = (e) -> console.log "Error putting data"; console.log e
            version_request.onblocked = (e) -> console.log "Blocked setting version"; console.log e
            version_request.onerror = (e) -> console.log "Error setting version"; console.log e
            version_request.onfailure = (e) -> console.log "Failure setting version"; console.log e
        else
          request = @idb.indexedDB.open @idb.db
          request.onsuccess = (e) =>
            idb = e.target.result
            @idb.put os, new_version, data, idb
          request.onerror = (e) ->
            console.log "ERROR: Unable to open indexedDB"
            #failure
      
      
      dump_s3: (ssid, stores, success, failure) =>
        # cache all assets of the specified shape_set from s3 using a single transaction
        # use one object store per object type and one object per shape_set
        ssid = parseInt(ssid)
        stores = stores or (os for os in @idb.config.stores when @idb.db.objectStoreNames.contains(os) and (@s3[ssid][os] or os == "shape_set"))
        t = @idb.db.transaction(stores, "readwrite")
        for os in stores
          active_store = t.objectStore(os)
          data = {}
          data[@idb.config.key] = ssid
          data.type = os
          if os == "shape_set"
            for attr of @s3[ssid]
              continue if attr in stores
              data[attr] = @s3[ssid][attr]
          else if os == "regions" # a region's object cannot be stored in indexedDB so a copy of the region minus is object should be stored instead
            for r of @s3[ssid][os]
              data[r] = {}
              for ri of @s3[ssid][os][r]
                data[r][ri] = @s3[ssid][os][r][ri] unless ri == 'object'
          else 
            $.extend(data, @s3[ssid][os])
          preq = active_store.put data
          preq.onsuccess = (e) -> console.log "Data stored in indexedDB"
          preq.error = (e) -> console.log "Error putting data"; console.log e; failure e if failure
        success e if success            
        undefined        
      
      load_s3: (ssid, success, failure) =>
        # load all items of the given shape_set from idb into s3
        ssid = parseInt(ssid)
        stores = (os for os in @idb.config.stores when @idb.db.objectStoreNames.contains(os) and os != "logs")
        console.log stores
        t = @idb.db.transaction(stores, "readwrite")
        for os in stores
          active_store = t.objectStore(os)
          greq = active_store.get ssid
          greq.onsuccess = (e) =>
            return false unless result = e.target.result
            @s3[ssid] ?= {}
            os = result.type
            delete result['type']
            delete result['ssid']
            if os == "shape_set"
              @s3[ssid][attr] = result[attr] for attr of result
            else
              for id of result
                @s3[ssid][os][id] ?= {} 
                for attr of result[id]
                  @s3[ssid][os][id][attr] = result[id][attr]
          greq.onerror = (e) -> console.log "ERROR: Unable to retrieve data for " + os
        success e if success
        undefined          
          
        
      clear: () -> 0
    
  
  perspective2region_descs: (json_data) ->
    regions = []
    meshes = {}
    for region in json_data["regions"]
      new_region = []
      shape_vids = (shape["volume_value"] for shape in region["shapes"])
      for shape in region["shapes"]
        for mesh in shape["meshes"]
          bf = mesh["name"].split("-")
          if (bf[0] in shape_vids) or (bf[1] in shape_vids)
            mesh_id = parseInt(mesh["id"])
            meshes[mesh_id] = mesh if mesh["included"] == "yes"
            new_region.push mesh_id
      regions.push new_region
    ((meshes[mesh_id] for mesh_id in region) for region in regions)
  
  fetch_defaults: (callback) ->
    $.ajax
      url: @jax_data_path
      dataType: 'json'
      error: (jqXHR, textStatus, errorThrown) -> console.log "AJAX Error: " + textStatus
      success: (data, textStatus, jqXHR) =>
        this.cache_shape_set data.default_shape_set        
        callback(data, textStatus, jqXHR)
  
  cache_shape_set: (ss) ->
    @s3[ss.id] ?= {}
    @s3[ss.id].id ?= ss.id
    @s3[ss.id].name ?= ss.name
    @s3[ss.id].radius ?= ss.radius
    @s3[ss.id].center_point ?= ss.center_point  
  
  cache_perspective: (p,ss) ->
    p_def = 
      id: p.id or 'lp'+Date.now() # loaded perspective
      name: p.name
      style_set: p.style_set
      height: p.height
      angle: p.angle
      distance: p.distance
      regions: p.regions
    @s3[ss].perspectives[p_def.id] = p_def
    return p_def.id
  
  fetch_shape_set: (ss,callback,cascade) ->
    params =
      shape_set: ss
      cascade: cascade or "no"
    this.fetch params, callback
  
  fetch_regions: (shape_set_id, region_ids, callback) ->
	  # should compose the params to fetch the requested regions, excluding already aquired meshes
    params =
      shape_set: shape_set_id
      requests: []
    for rid in region_ids
      params.requests.push
        type:"region"
        id: rid
        cascade:"yes"
    if @s3[shape_set_id].meshes.length
      params.exclude = []
      params.exclude.push mesh_id for mesh_id of @s3.meshes
    this.fetch params, callback
	
  fetch: (params, callback) ->
    # params = {shape_set: #, include:[], exclude:[], cascade:flag, requests: {}}
    @s3[params.shape_set] ?= {}
    @s3[params.shape_set].perspectives ?= {}
    @s3[params.shape_set].meshes ?= {}
    @s3[params.shape_set].shapes ?= {}
    @s3[params.shape_set].regions ?= {}
    url = @jax_data_path
    url += "/" + params.shape_set if params.shape_set
    url += "?" if params.include or params.exclude or params.requests or params.cascade
    if params.include and params.include.length
      url += "include=" + params.include.uniq() + "&"
    else if params.exclude and params.exclude.length
      url += "exclude=" + params.exclude.uniq() + "&"
    if params.requests
      url += "requests=" + encodeURIComponent(JSON.stringify(params.requests))
    else if params.cascade
      url += "cascade=" + params.cascade
    console.log url
    $.ajax
      url: url
      dataType: 'json'
      error: (jqXHR, textStatus, errorThrown) -> console.log "AJAX Error: " + textStatus
      success: (data, textStatus, jqXHR) =>
        perspective_proc = (shape_set_id, perspective, region_proc, shape_proc, mesh_proc) =>
          perspective_def = 
            id: perspective.id
            name: perspective.name
            style_set: perspective.style_set
            height: perspective.height
            angle: perspective.angle
            distance: perspective.distance
            regions: []
          
          if "regions" of perspective
            for region in perspective.regions
              perspective_def.regions.push region.id
              region_proc(shape_set_id, region, shape_proc, mesh_proc)
          @s3[shape_set_id].perspectives[perspective.id] = perspective_def 
        
        region_proc = (shape_set_id, region, shape_proc, mesh_proc) =>
          region_def = 
            id: region.id
            name: region.name
            decompositions: region.decompositions
            thing: region.thing
            shapes: []
          if "shapes" of region
            for shape in region.shapes
              region_def.shapes.push shape.id
              shape_proc(shape_set_id, shape, mesh_proc)
          @s3[shape_set_id].regions[region.id] = region_def 
        
        shape_proc = (shape_set_id, shape, mesh_proc) =>
          shape_def =
            id: shape.id
            volume_value: shape.volume_value
            name: shape.name
            meshes: []
          if "meshes" of shape
            for mesh in shape["meshes"]
              if mesh.included == "yes" or mesh.included == "elsewhere" # not entirely sure why this is neccessary ?
                shape_def.meshes.push mesh.id
              if mesh.included == "yes"
                mesh_proc(shape_set_id, mesh)
          @s3[shape_set_id].shapes[shape.id] = shape_def
        
        mesh_proc = (shape_set_id, mesh) =>
          @s3[shape_set_id].meshes[mesh.id] =
            id: mesh.id
            name: mesh.name
            vertex_positions: mesh.vertex_positions
            vertex_normals: mesh.vertex_normals
            faces: mesh.faces
            borders: mesh.borders
        
        unless "default_shape_set" of data # not sure if this is necccessary
          for ri of data
            if params.requests and "type" of params.requests[ri]
              switch params.requests[ri].type
                when "perspective"                  
                  perspective_proc(params.shape_set, data[ri], region_proc, shape_proc, mesh_proc)
                when "region"
                  region_proc(params.shape_set, data[ri], shape_proc, mesh_proc)
                when "shape"
                  shape_proc(params.shape_set, data[ri], shape_proc, mesh_proc)
                when "mesh"
                  mesh_proc(params.shape_set, data[ri])
            else
              this.cache_shape_set data[ri]
        callback(data, textStatus, jqXHR)
  