Jax.getGlobal()['AssetLoader'] = Jax.Model.create
  after_initialize: ->
    # this model is responsible for finding, fetching and returning requested meshes, regions, descriptions, indexes etc
    # particularly in service of scene and region
    # also responsible for local caching of assets
    # can bundle assets into a single request to the server to reduce overhead
    
    # create jax asset store
    # all meshes are stripped out of the loaded asset and stored here by id, where region can find them later
    window.context.s3 = {}
  
  perspective2region_descs: (json_data) ->
    regions = []
    meshes = {}
    for region in json_data["regions"]
      new_region = []
      shape_vids = (shape["volume_value"] for shape in region["shapes"])
      for shape in region["shapes"]
        for mesh in shape["meshes"]
          bf = mesh["name"].split("-")
          if (bf[0] in shape_vids) or (bf[1] in shape_vids)
            mesh_id = parseInt(mesh["id"])
            meshes[mesh_id] = mesh if mesh["included"] == "yes"
            new_region.push mesh_id
      regions.push new_region
    ((meshes[mesh_id] for mesh_id in region) for region in regions)
  
  fetch_defaults: (callback) ->
    $.ajax
      url: @jax_data_path
      dataType: 'json'
      error: (jqXHR, textStatus, errorThrown) -> console.log "AJAX Error: " + textStatus
      success: (data, textStatus, jqXHR) ->
        shape_set = data.default_shape_set        
        window.context.s3[shape_set.id] ?= {}
        window.context.s3[shape_set.id].id ?= shape_set.id
        window.context.s3[shape_set.id].name ?= shape_set.name
        window.context.s3[shape_set.id].radius ?= shape_set.radius
        window.context.s3[shape_set.id].center_point ?= shape_set.center_point
        callback(data, textStatus, jqXHR)
  
  fetch_regions: (shape_set_id, region_ids, callback) ->
	  # should compose the params to fetch the requested regions, excluding already aquired meshes
    params =
      shape_set: shape_set_id
      requests: []
    for rid in region_ids
      params.requests.push
        type:"region"
        id: rid
        cascade:"yes"
    if window.context.s3[shape_set_id].meshes.length
      params.exclude = []
      params.exclude.push mesh_id for mesh_id of window.context.s3.meshes
    this.fetch params, callback
	
  fetch: (params, callback) ->
    # params = {shape_set: #, include:[], exclude:[], cascade:flag, requests: {}}
    window.context.s3[params.shape_set] ?= {}
    window.context.s3[params.shape_set].perspectives ?= {}
    window.context.s3[params.shape_set].meshes ?= {}
    window.context.s3[params.shape_set].shapes ?= {}
    window.context.s3[params.shape_set].regions ?= {}
    url = @jax_data_path
    url += "/" + params.shape_set if params.shape_set
    url += "?" if params.include or params.exclude or params.requests or params.cascade
    if params.include and params.include.length
      url += "include=" + params.include + "&"
    else if params.exclude and params.exclude.length
      url += "exclude=" + params.exclude + "&"
    if params.requests
      url += "requests=" + encodeURIComponent(JSON.stringify(params.requests))
    else if params.cascade
      url += "cascade=" + params.cascade
    console.log url
    $.ajax
      url: url
      dataType: 'json'
      error: (jqXHR, textStatus, errorThrown) -> console.log "AJAX Error: " + textStatus
      success: (data, textStatus, jqXHR) ->
        perspective_proc = (shape_set_id, perspective, region_proc, shape_proc, mesh_proc) ->
          perspective_def = 
            id: perspective.id
            name: perspective.name
            style_set: perspective.style_set
            height: perspective.height
            angle: perspective.angle
            distance: perspective.distance
            regions: []
          
          if "regions" of perspective
            for region in perspective.regions
              perspective_def.regions.push region.id
              region_proc(shape_set_id, region, shape_proc, mesh_proc)
          window.context.s3[shape_set_id].perspectives[perspective.id] = perspective_def 
        
        region_proc = (shape_set_id, region, shape_proc, mesh_proc) ->
          region_def = 
            id: region.id
            name: region.name
            decompositions: region.decompositions
            shapes: []
          if "shapes" of region
            for shape in region.shapes
              region_def.shapes.push shape.id
              shape_proc(shape_set_id, shape, mesh_proc)
          window.context.s3[shape_set_id].regions[region.id] = region_def 
        
        shape_proc = (shape_set_id, shape, mesh_proc) ->
          shape_def =
            id: shape.id
            volume_value: shape.volume_value
            name: shape.name
            meshes: []
          if "meshes" of shape
            for mesh in shape["meshes"]
              if mesh.included == "yes" or mesh.included == "elsewhere" # not entirely sure why this is neccessary ?
                shape_def.meshes.push mesh.id
              if mesh.included == "yes"
                mesh_proc(shape_set_id, mesh)
          window.context.s3[shape_set_id].shapes[shape.id] = shape_def
        
        mesh_proc = (shape_set_id, mesh) ->
          window.context.s3[shape_set_id].meshes[mesh.id] =
            id: mesh.id
            name: mesh.name
            vertex_positions: mesh.vertex_positions
            vertex_normals: mesh.vertex_normals
            faces: mesh.faces
            borders: mesh.borders
        
        unless "default_shape_set" of data # not sure if this is necccessary
          for ri of data
            if "type" of params.requests[ri]
              switch params.requests[ri].type
                when "perspective"                  
                  perspective_proc(params.shape_set, data[ri], region_proc, shape_proc, mesh_proc)
                when "region"
                  region_proc(params.shape_set, data[ri], shape_proc, mesh_proc)
                when "shape"
                  shape_proc(params.shape_set, data[ri], shape_proc, mesh_proc)
                when "mesh"
                  mesh_proc(params.shape_set, data[ri])
            else
              null # it's a shape_set
        callback(data, textStatus, jqXHR)





